
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  技术积累
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="技术积累" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">技术积累</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302416575923.html">Git安装</a></h1>
			<p class="meta"><time datetime="2018-06-29T11:07:37+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">在Linux上安装Git</h3>

<p>首先，你可以试着输入git，看看系统有没有安装Git：</p>

<pre><code>$ git
The program &#39;git&#39; is currently not installed. You can install it by typing:
sudo apt-get install git
</code></pre>

<p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>

<blockquote>
<p>如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。</p>

<p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。</p>

<p>也可以直接使用yum安装 </p>
</blockquote>

<h3 id="toc_1">在Mac OS X上安装Git</h3>

<p>如果你正在使用Mac做开发，有两种安装Git的方法。</p>

<blockquote>
<ol>
<li>安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/">http://brew.sh/</a>。</li>
<li>方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</li>
</ol>
</blockquote>

<h3 id="toc_2">在Windows上安装Git</h3>

<p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads">下载安装程序</a>，（网速慢的同学请移步<a href="https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit">国内镜像</a>），然后按默认选项安装即可。</p>

<p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>

<h3 id="toc_3">配置git全局用户名</h3>

<p>安装完成后，还需要最后一步设置，在命令行输入：</p>

<pre><code>$ git config --global user.name &quot;Your Name&quot;
$ git config --global user.email 
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302427999465.html">版本库创建</a></h1>
			<p class="meta"><time datetime="2018-06-29T11:26:39+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>

<h3 id="toc_0">创建空目录</h3>

<p>创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录(Mac如下)：</p>

<pre><code class="language-mac">$ mkdir learngit
$ cd learngit
$ pwd
/Users/michael/learngit
</code></pre>

<p><em>Window注意事项见附录<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></em></p>

<h3 id="toc_1">初始化仓库</h3>

<p>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p>

<pre><code class="language-mac">$ git init
Initialized empty Git repository in /Users/michael/learngit/.git/
</code></pre>

<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>

<p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p>

<h3 id="toc_2">添加到版本库</h3>

<blockquote>
<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>

<p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p>

<p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
</blockquote>

<p>言归正传，现在我们编写一个readme.md文件，内容如下：</p>

<pre><code class="language-mac">### Git Demo Project
Git is a version control system.
Git is free software.
</code></pre>

<p>一定要放到上面我们新建目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p>

<p>接下来，我们把文件添加到版本库</p>

<ol>
<li>用命令<code>git add</code>告诉Git，把文件添加到仓库：</li>
</ol>

<pre><code class="language-mac">$ git add readme.md
</code></pre>

<p>mac执行上面的命令，如果没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”</p>

<ol>
<li>用命令git commit告诉Git，把文件提交到仓库</li>
</ol>

<pre><code class="language-mac">$ git commit -m &quot;wrote a readme file&quot;
[master (root-commit) eaadf4e] wrote a readme file
 1 file changed, 3 insertions(+)
 create mode 100644 readme.txt
</code></pre>

<p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>

<p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是<strong>强烈不建议</strong>你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p>

<p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>3 insertions</code>：插入了两行内容（readme.md有两行内容）。</p>

<h3 id="toc_3">说明</h3>

<p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>

<pre><code class="language-mac">$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m &quot;add 3 files.&quot;
</code></pre>

<p><code>git add</code>不仅可以添加多个文件，还可以添加文件目录，如全工程添加，可以使用 <code>git add .</code></p>

<h3 id="toc_4">小结</h3>

<p>现在总结一下：<br/>
初始化一个Git仓库，使用<code>git init</code>命令。<br/>
添加文件到Git仓库，分两步：<br/>
使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；<br/>
使用命令<code>git commit -m &lt;message&gt;</code>，完成。</p>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302446124635.html">版本更新</a></h1>
			<p class="meta"><time datetime="2018-06-29T11:56:52+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">修改文件</h3>

<p>我们已经成功地添加并提交了一个readme.md文件，现在，是时候继续工作了，于是，我们继续修改readme.md文件，改成如下内容：</p>

<pre><code class="language-mac">### Git Demo Project
Git is a distributed version control system.
Git is free software.
</code></pre>

<p>现在，运行<code>git status</code>命令看看结果：</p>

<pre><code class="language-mac">$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>

<p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.md</code>被修改过了，但还没有准备提交的修改。</p>

<p>虽然Git告诉我们<code>readme.md</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周，第一天上班时，已经记不清上次怎么修改的<code>readme.md</code>，所以，需要用git diff这个命令看看：</p>

<pre><code class="language-mac">$ git diff readme.txt 
diff --git a/readme.txt b/readme.txt
index 46d49bf..9247db6 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,2 +1,2 @@
-Git is a version control system.
+Git is a distributed version control system.
 Git is free software.
</code></pre>

<p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。</p>

<p>知道了对readme.md作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p>

<pre><code class="language-mac">$ git add readme.md
</code></pre>

<p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p>

<pre><code class="language-mac">$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    modified:   readme.txt
</code></pre>

<p><code>git status</code>告诉我们，将要被提交的修改包括readme.md，下一步，就可以放心地提交了：</p>

<pre><code class="language-mac">$ git commit -m &quot;add distributed&quot;
[master e475afc] add distributed
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>

<p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p>

<pre><code class="language-mac">$ git status
On branch master
nothing to commit, working tree clean
</code></pre>

<h3 id="toc_1">小结</h3>

<p>现在总结一下：<br/>
要随时掌握工作区的状态，使用<code>git status</code>命令。<br/>
如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302503418505.html">版本回退</a></h1>
			<p class="meta"><time datetime="2018-06-29T13:32:21+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">查看版本记录</h3>

<p>在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p>

<pre><code class="language-mac">$ git log
commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:03:36 2018 +0800

    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 20:59:18 2018 +0800

    wrote a readme file
</code></pre>

<p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到2次提交，上一次是add distributed，最早的一次是wrote a readme file。</p>

<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p>

<pre><code class="language-mac">$ git log --pretty=oneline
1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)  add distributed
eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file
</code></pre>

<p>需要友情提示的是，你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>

<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线。</p>

<h3 id="toc_1">回退到上个版本</h3>

<p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<sup>比较容易数不过来，所以写成<code>HEAD~100</code>。</sup></p>

<p>现在，我们要把当前版本add distributed回退到上一个版本a，就可以使用git reset命令：</p>

<pre><code class="language-mac">$ git reset --hard HEAD^
HEAD is now at eaadf4e add distributed
</code></pre>

<p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。<br/>
接下来看看readme.md的内容是不是最开始的版本wrote a readme file</p>

<p>最新的那个版本append distributed已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>

<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个add distributed的commit id是1094adb...，于是就可以指定回到未来的某个版本：</p>

<pre><code class="language-mac">$ git reset --hard 1094a
HEAD is now at 83b0afe append GPL
</code></pre>

<p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>

<p>再小心翼翼地看看readme.md的内容：</p>

<pre><code class="language-mac">### Git Demo Project
Git is a distributed version control system.
Git is free software.
</code></pre>

<h3 id="toc_2">操作记录</h3>

<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向初始版本,然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p>

<p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>wrote a readme file</code><br/>
版本时，再想恢复到<code>add distributed</code>，就必须找到<code>add distributed</code>的<code>commit id</code>。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p>

<pre><code class="language-mac">$ git reflog
e475afc HEAD@{1}: reset: moving to HEAD^
1094adb (HEAD -&gt; master) HEAD@{2}: commit: add distributed
eaadf4e HEAD@{3}: commit (initial): wrote a readme file
</code></pre>

<p>终于舒了口气，从输出可知，<code>add distributed</code>的<code>commit id</code>是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p>

<h3 id="toc_3">小结</h3>

<p>现在总结一下：<br/>
HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。<br/>
穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。<br/>
要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302512669411.html">工作区和暂存区</a></h1>
			<p class="meta"><time datetime="2018-06-29T13:47:46+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">工作区</h3>

<p>就是你在电脑里能看到的目录，比如执行git init文件夹就是一个工作区</p>

<h3 id="toc_1">版本库（Repository）</h3>

<p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>

<p>Git的版本库里存了很多东西，其中最重要的就是称为<code>stage</code>（或者叫<code>index</code>）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0" alt=""/></p>

<p>分支和HEAD的概念我们以后再讲。<br/>
前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>

<ol>
<li>用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</li>
<li>用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li>
</ol>

<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>

<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>

<p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.md</code>做个修改，比如加上一行内容：</p>

<pre><code class="language-mac">Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
</code></pre>

<p>然后，在工作区新增一个LICENSE文本文件（内容随便写）。<br/>
先用<code>git status</code>查看一下状态：</p>

<pre><code class="language-mac">$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
    modified:   readme.txt
Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
    LICENSE
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>

<p>Git非常清楚地告诉我们，<code>readme.md</code>被修改了，而LICENSE还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>

<p>现在，使用两次命令<code>git add</code>，把<code>readme.md</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>

<pre><code class="language-mac">$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   LICENSE
    modified:   readme.txt
</code></pre>

<p>现在，暂存区的状态就变成这样了：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907720458e56751df1c474485b697575073c40ae9000/0" alt=""/></p>

<p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>

<pre><code class="language-mac">$ git commit -m &quot;understand how stage works&quot;
[master e43a48b] understand how stage works
 2 files changed, 2 insertions(+)
 create mode 100644 LICENSE
</code></pre>

<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：<br/>
<code>mac<br/>
$ git status<br/>
On branch master<br/>
nothing to commit, working tree clean<br/>
</code></p>

<p>现在版本库变成了这样，暂存区就没有任何内容了：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013849077337835a877df2d26742b88dd7f56a6ace3ecf000/0" alt=""/></p>

<p>工作区和暂存区<br/>
阅读: 791811<br/>
Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>

<p>先来看名词解释。</p>

<p>工作区（Working Directory）<br/>
就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：</p>

<p>working-dir</p>

<p>版本库（Repository）<br/>
工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p>

<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p>

<p>git-repo</p>

<p>分支和HEAD的概念我们以后再讲。</p>

<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>

<p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p>

<p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>

<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p>

<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>

<p>俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：</p>

<p>Git is a distributed version control system.<br/>
Git is free software distributed under the GPL.<br/>
Git has a mutable index called stage.<br/>
然后，在工作区新增一个LICENSE文本文件（内容随便写）。</p>

<p>先用git status查看一下状态：</p>

<p>$ git status<br/>
On branch master<br/>
Changes not staged for commit:<br/>
  (use &quot;git add <file>...&quot; to update what will be committed)<br/>
  (use &quot;git checkout -- <file>...&quot; to discard changes in working directory)</p>

<pre><code>modified:   readme.txt
</code></pre>

<p>Untracked files:<br/>
  (use &quot;git add <file>...&quot; to include in what will be committed)</p>

<pre><code>LICENSE
</code></pre>

<p>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br/>
Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。</p>

<p>现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：</p>

<p>$ git status<br/>
On branch master<br/>
Changes to be committed:<br/>
  (use &quot;git reset HEAD <file>...&quot; to unstage)</p>

<pre><code>new file:   LICENSE
modified:   readme.txt
</code></pre>

<p>现在，暂存区的状态就变成这样了：</p>

<p>git-stage</p>

<p>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p>

<p>$ git commit -m &quot;understand how stage works&quot;<br/>
[master e43a48b] understand how stage works<br/>
 2 files changed, 2 insertions(+)<br/>
 create mode 100644 LICENSE<br/>
一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>

<p>$ git status<br/>
On branch master<br/>
nothing to commit, working tree clean<br/>
现在版本库变成了这样，暂存区就没有任何内容了：</p>

<p>git-stage-after-commit</p>

<h3 id="toc_2">小结</h3>

<p>现在总结一下：<br/>
暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。<br/>
没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302521579062.html">管理修改</a></h1>
			<p class="meta"><time datetime="2018-06-29T14:02:37+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p>

<h3 id="toc_0">管理修改并非文件</h3>

<p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>

<p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.md做一个修改，比如加一行内容：</p>

<pre><code class="language-mac">$ cat readme.md
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes.
</code></pre>

<p>然后，添加：</p>

<pre><code class="language-mac">$ git add readme.md
$ git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       modified:   readme.txt
#
</code></pre>

<p>然后，再修改readme.md：</p>

<pre><code class="language-mac">$ cat readme.md
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre>

<p>提交后，再看看状态：</p>

<pre><code class="language-mac">$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>

<p>咦，怎么第二次的修改没有被提交？</p>

<p>别激动，我们回顾一下操作过程：<br/>
第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p>

<p>你看，我们前面讲了，Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>

<p>提交后，用<code>git diff HEAD -- readme.md</code>命令可以查看工作区和版本库里面最新版本的区别：</p>

<pre><code class="language-mac">$ git diff HEAD -- readme.md 
diff --git a/readme.md b/readme.md
index 76d770f..a9c5755 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,4 +1,4 @@
 Git is a distributed version control system.
 Git is free software distributed under the GPL.
 Git has a mutable index called stage.
-Git tracks changes.
+Git tracks changes of files.
</code></pre>

<p>可见，第二次修改确实没有被提交。</p>

<p>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：</p>

<p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p>

<p>好，现在，把第二次修改提交了，然后开始小结。</p>

<h3 id="toc_1">小结</h3>

<p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>git commit</code>中。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302528503439.html">撤销修改</a></h1>
			<p class="meta"><time datetime="2018-06-29T14:14:10+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">撤销工作区修改</h3>

<p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.md中添加了一行：</p>

<pre><code class="language-mac">$ cat readme.md
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.
</code></pre>

<p>在你准备提交前，一杯咖啡起了作用，你猛然发现了stupid boss可能会让你丢掉这个月的奖金！</p>

<p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p>

<pre><code class="language-mac">$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>

<p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p>

<pre><code class="language-mac">$ git checkout -- readme.md
````
命令`git checkout -- readme.md`意思就是，把`readme.md`文件在工作区的修改全部撤销，这里有两种情况：

一种是`readme.md`自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；

一种是`readme.md`已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。

总之，就是让这个文件回到最近一次`git commit`或`git add`时的状态。

现在，看看readme.md的文件内容：

```mac
$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre>

<p>文件内容果然复原了。</p>

<p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p>

<h3 id="toc_1">撤销暂存区修改</h3>

<p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p>

<pre><code class="language-mac">$ cat readme.md
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.

$ git add readme.md
</code></pre>

<p>庆幸的是，在commit之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p>

<pre><code class="language-mac">$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    modified:   readme.md
</code></pre>

<p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p>

<pre><code class="language-mac">$ git reset HEAD readme.md
Unstaged changes after reset:
M    readme.md
</code></pre>

<p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p>

<p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p>

<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   readme.md
</code></pre>

<p>还记得如何丢弃工作区的修改吗？</p>

<pre><code>$ git checkout -- readme.md

$ git status
On branch master
nothing to commit, working tree clean
</code></pre>

<p>整个世界终于清静了！</p>

<h3 id="toc_2">版本回退</h3>

<p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得<strong>版本回退</strong>一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把stupid boss提交推送到远程版本库，你就真的惨了……</p>

<h3 id="toc_3">小结</h3>

<p>现在总结一下：</p>

<ol>
<li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li>
<li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li>
<li>已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302532981677.html">删除文件</a></h1>
			<p class="meta"><time datetime="2018-06-29T14:21:38+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">删除文件</h3>

<p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：</p>

<pre><code class="language-mac">$ git add test.txt

$ git commit -m &quot;add test.txt&quot;
[master b84166e] add test.txt
 1 file changed, 1 insertion(+)
 create mode 100644 test.txt
 ```
一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：

```mac
$ rm test.txt
</code></pre>

<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</p>

<pre><code class="language-mac">$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    deleted:    test.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>

<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p>

<pre><code class="language-mac">$ git rm test.txt
rm &#39;test.txt&#39;

$ git commit -m &quot;remove test.txt&quot;
[master d46f35e] remove test.txt
 1 file changed, 1 deletion(-)
 delete mode 100644 test.txt
</code></pre>

<p>现在，文件就从版本库中被删除了。</p>

<p><em>提示：<code>git add</code>和<code>git rm</code>的区别<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></em></p>

<h3 id="toc_1">恢复删除文件</h3>

<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>

<pre><code class="language-mac">$ git checkout -- test.txt
</code></pre>

<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>

<h3 id="toc_2">小结</h3>

<p>现在总结一下：</p>

<p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302538220259.html">远程仓库</a></h1>
			<p class="meta"><time datetime="2018-06-29T14:30:22+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">将本地仓库和远程仓库关联</h3>

<p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>

<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013849084639042e9b7d8d927140dba47c13e76fe5f0d6000/0" alt=""/><br/>
在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013849084720379a3eae576b9f417da2add578c8612a2e000/0" alt=""/><br/>
目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>

<p>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：</p>

<pre><code class="language-mac">$ git remote add origin git@github.com:michaelliao/learngit.git
</code></pre>

<p><em>注：也可以是http的地址，如下<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></em></p>

<p>请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>

<p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p>

<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>

<pre><code class="language-mac">$ git push -u origin master
Counting objects: 20, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.
Total 20 (delta 5), reused 0 (delta 0)
remote: Resolving deltas: 100% (5/5), done.
To github.com:michaelliao/learngit.git
 * [new branch]      master -&gt; master
Branch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;origin&#39;.
</code></pre>

<p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支master推送到远程。</p>

<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>

<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/00138490848464619aebd9a2bb0493c83e132ca1eed6f66000/0" alt=""/></p>

<p>从现在起，只要本地作了提交，就可以通过命令：</p>

<pre><code class="language-mac">$ git push origin master
</code></pre>

<p>把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>

<h3 id="toc_1">小结</h3>

<p>现在总结一下：</p>

<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p>

<p>关联后，使用命令<code>git push -u origin master</code>第一次推送<code>master</code>分支的所有内容；</p>

<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>

<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>http的如下<code>git remote add origin http://www.github.com/devin/xxx.git</code>&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302542722207.html">从远程库克隆</a></h1>
			<p class="meta"><time datetime="2018-06-29T14:37:52+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。<br/>
现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。<br/>
首先，登陆GitHub，创建一个新的仓库，名字叫<code>gitskills</code>：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013849085474010fec165e9c7449eea4417512c2b64bc9000/0" alt=""/></p>

<p>我们勾选<code>Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个<code>README.md</code>文件。创建完毕后，可以看到<code>README.md</code>文件：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013849085607106c2391754c544772830983d189bad807000/0" alt=""/></p>

<p>现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：</p>

<pre><code class="language-mac">$ git clone git@github.com:michaelliao/gitskills.git
Cloning into &#39;gitskills&#39;...
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3
Receiving objects: 100% (3/3), done.
</code></pre>

<p>注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了：</p>

<pre><code class="language-mac">$ cd gitskills
$ ls
README.md
</code></pre>

<p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>

<p>你也许还注意到，GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</p>

<p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p>

<h3 id="toc_0">小结</h3>

<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。<br/>
Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302544159488.html">分支管理</a></h1>
			<p class="meta"><time datetime="2018-06-29T14:40:15+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">创建和合并分支:理论</h3>

<p>在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p>

<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用HEAD指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013849087937492135fbf4bbd24dfcbc18349a8a59d36d000/0" alt=""/></p>

<p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长</p>

<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384908811773187a597e2d844eefb11f5cf5d56135ca000/0" alt=""/></p>

<p>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p>

<p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013849088235627813efe7649b4f008900e5365bb72323000/0" alt=""/></p>

<p>假如我们在dev上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/00138490883510324231a837e5d4aee844d3e4692ba50f5000/0" alt=""/></p>

<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>

<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384908867187c83ca970bf0f46efa19badad99c40235000/0" alt=""/></p>

<h3 id="toc_1">创建和合并分支:实战</h3>

<p>下面开始实战。</p>

<p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p>

<pre><code class="language-mac">$ git checkout -b dev
Switched to a new branch &#39;dev&#39;
</code></pre>

<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p>

<pre><code class="language-mac">$ git branch dev
$ git checkout dev
Switched to branch &#39;dev&#39;
</code></pre>

<p>然后，用<code>git branch</code>命令查看当前分支：</p>

<pre><code class="language-mac">$ git branch
* dev
  master
</code></pre>

<p>git branch命令会列出所有分支，当前分支前面会标一个*号。</p>

<p>然后，我们就可以在dev分支上正常提交，比如对<code>readme.md</code>做个修改，加上一行：</p>

<pre><code class="language-mac">Creating a new branch is quick.
</code></pre>

<p>然后提交：</p>

<pre><code class="language-mac">$ git add readme.md
$ git commit -m &quot;branch test&quot;
[dev b17d20e] branch test
 1 file changed, 1 insertion(+)
</code></pre>

<p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p>

<pre><code class="language-mac">$ git checkout master
Switched to branch &#39;master&#39;
</code></pre>

<p>切换回<code>master</code>分支后，再查看一个<code>readme.md</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384908892295909f96758654469cad60dc50edfa9abd000/0" alt=""/></p>

<p>现在，我们把dev分支的工作成果合并到master分支上：</p>

<pre><code class="language-mac">$ git merge dev
Updating d46f35e..b17d20e
Fast-forward
 readme.txt | 1 +
 1 file changed, 1 insertion(+)
 ```
```git merge```命令用于合并指定分支到当前分支。合并后，再查看```readme.md```的内容，就可以看到，和dev分支的最新提交是完全一样的。

注意到上面的`Fast-forward`信息，Git告诉我们，这次合并是“快进模式”，也就是直接把`master`指向`dev`的当前提交，所以合并速度非常快。

当然，也不是每次合并都能`Fast-forward`，我们后面会讲其他方式的合并。

合并完成后，就可以放心地删除`dev`分支了：

```mac
$ git branch -d dev
Deleted branch dev (was b17d20e).
</code></pre>

<p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p>

<pre><code class="language-mac">$ git branch
* master
</code></pre>

<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302549697544.html">解决冲突</a></h1>
			<p class="meta"><time datetime="2018-06-29T14:49:29+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">冲突的产生</h3>

<p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>

<p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p>

<pre><code class="language-mac">$ git checkout -b feature1
Switched to a new branch &#39;feature1&#39;
</code></pre>

<p>修改<code>readme.md</code>最后一行，改为：</p>

<pre><code class="language-mac">Creating a new branch is quick AND simple.
</code></pre>

<p>在feature1分支上提交：</p>

<pre><code class="language-mac">$ git add readme.md

$ git commit -m &quot;AND simple&quot;
[feature1 14096d0] AND simple
 1 file changed, 1 insertion(+), 1 deletion(-)
 ```
 
切换到master分支：

```mac
$ git checkout master
Switched to branch &#39;master&#39;
Your branch is ahead of &#39;origin/master&#39; by 1 commit.
  (use &quot;git push&quot; to publish your local commits)
</code></pre>

<p>Git还会自动提示我们当前<code>feature1</code>分支比远程的<code>master</code>分支要超前1个提交。</p>

<p>在<code>master</code>分支上把<code>readme.md</code>文件的最后一行改为：</p>

<pre><code class="language-mac">Creating a new branch is quick &amp; simple.
</code></pre>

<p>提交：</p>

<pre><code class="language-mac">$ git add readme.md 
$ git commit -m &quot;&amp; simple&quot;
[master 5dc6824] &amp; simple
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>

<p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909115478645b93e2b5ae4dc78da049a0d1704a41000/0" alt=""/></p>

<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p>

<pre><code class="language-mac">$ git merge feature1
Auto-merging readme.md
CONFLICT (content): Merge conflict in readme.md
Automatic merge failed; fix conflicts and then commit the result.
</code></pre>

<p>果然冲突了！Git告诉我们，<code>readme.md</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p>

<pre><code class="language-mac">$ git status
On branch master
Your branch is ahead of &#39;origin/master&#39; by 2 commits.
  (use &quot;git push&quot; to publish your local commits)

You have unmerged paths.
  (fix conflicts and run &quot;git commit&quot;)
  (use &quot;git merge --abort&quot; to abort the merge)

Unmerged paths:
  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)

    both modified:   readme.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>

<p>我们可以直接查看readme.md的内容：</p>

<pre><code class="language-mac">Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Creating a new branch is quick &amp; simple.
=======
Creating a new branch is quick AND simple.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1
</code></pre>

<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>

<pre><code class="language-mac">Creating a new branch is quick and simple.
</code></pre>

<p>再提交：</p>

<pre><code class="language-mac">$ git add readme.md 
$ git commit -m &quot;conflict fixed&quot;
[master cf810e4] conflict fixed
</code></pre>

<p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/00138490913052149c4b2cd9702422aa387ac024943921b000/0" alt=""/></p>

<p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p>

<pre><code class="language-mac">$ git log --graph --pretty=oneline --abbrev-commit
*   cf810e4 (HEAD -&gt; master) conflict fixed
|\  
| * 14096d0 (feature1) AND simple
* | 5dc6824 &amp; simple
|/  
* b17d20e branch test
* d46f35e (origin/master) remove test.txt
* b84166e add test.txt
* 519219b git tracks changes
* e43a48b understand how stage works
* 1094adb append GPL
* e475afc add distributed
* eaadf4e wrote a readme file
</code></pre>

<p>最后，删除<code>feature1</code>分支：</p>

<pre><code class="language-mac">$ git branch -d feature1
Deleted branch feature1 (was 14096d0).
</code></pre>

<p>工作完成。</p>

<h3 id="toc_1">小结</h3>

<ol>
<li>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</li>
<li>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</li>
<li>用<code>git log --graph</code>命令可以看到分支合并图。</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302553109111.html">分支管理策略</a></h1>
			<p class="meta"><time datetime="2018-06-29T14:55:10+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">合并分支的方式</h3>

<p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>

<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在<code>merge</code>时生成一个新的<code>commit</code>，这样，从分支历史上就可以看出分支信息。</p>

<p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p>

<p>首先，仍然创建并切换dev分支：</p>

<pre><code class="language-mac">$ git checkout -b dev
Switched to a new branch &#39;dev&#39;
</code></pre>

<p>修改readme.md文件，并提交一个新的commit：</p>

<pre><code class="language-mac">$ git add readme.md 
$ git commit -m &quot;add merge&quot;
[dev f52c633] add merge
 1 file changed, 1 insertion(+)
 ```
现在，我们切换回`master`：

```mac
$ git checkout master
Switched to branch &#39;master&#39;
</code></pre>

<p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p>

<pre><code class="language-mac">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev
Merge made by the &#39;recursive&#39; strategy.
 readme.md | 1 +
 1 file changed, 1 insertion(+)
 ```
因为本次合并要创建一个新的`commit`，所以加上`-m`参数，把`commit`描述写进去。

合并后，我们用`git log`看看分支历史：

```mac
$ git log --graph --pretty=oneline --abbrev-commit
*   e1e9c68 (HEAD -&gt; master) merge with no-ff
|\  
| * f52c633 (dev) add merge
|/  
*   cf810e4 conflict fixed
...
</code></pre>

<p>可以看到，不使用<code>Fast forward</code>模式，<code>merge</code>后就像这样：</p>

<h3 id="toc_1">项目中分支策略</h3>

<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>

<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>

<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如<code>1.0</code>版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布<code>1.0</code>版本；</p>

<p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>

<p>所以，团队合作的分支看起来就像这样：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909239390d355eb07d9d64305b6322aaf4edac1e3000/0" alt=""/></p>

<h3 id="toc_2">小结</h3>

<ol>
<li>Git分支十分强大，在团队开发中应该充分应用。</li>
<li>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</li>
<li><strong>推荐加上<code>--no-ff</code>，这样可以产生提交记录，方便追溯。</strong></li>
<li><p>项目中一般有4个固定分支，</p>

<blockquote>
<p>a. <code>master</code>: 此分支是稳定分支，和线上版本代码必须完全一致<br/>
b. <code>hotfix</code>: 此分支是修复分支，一般和线上版本一致，若线上出现问题<br/>
c. <code>release</code>: 此分支是用户测试分支，一般和UAT或SIT环境代码完全一致<br/>
d. <code>dev</code>: 此分支为开发分支，也是最新功能的分支，一般和DEV环境代码一致。</p>
</blockquote></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302560370020.html">Bug分支</a></h1>
			<p class="meta"><time datetime="2018-06-29T15:07:17+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>

<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在dev上进行的工作还没有提交：</p>

<pre><code class="language-mac">$ git status
On branch dev
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   hello.py

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   readme.txt
</code></pre>

<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>

<p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>

<pre><code class="language-mac">$ git stash
Saved working directory and index state WIP on dev: f52c633 add merge
</code></pre>

<p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>

<p>首先确定要在哪个分支上修复bug，假定需要在<code>hotfix</code>分支上修复，就从<code>hotfix</code>创建临时分支：</p>

<pre><code class="language-mac">$ git checkout hotfix
Switched to branch &#39;hotfix&#39;
Your branch is ahead of &#39;origin/hotfix&#39; by 6 commits.
  (use &quot;git push&quot; to publish your local commits)

$ git checkout -b issue-101
Switched to a new branch &#39;issue-101&#39;
</code></pre>

<p>现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：</p>

<pre><code class="language-mac">$ git add readme.txt 
$ git commit -m &quot;fix bug 101&quot;
[issue-101 4c805e2] fix bug 101
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>

<p>修复完成后，切换到<code>hotfix</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p>

<pre><code class="language-mac">$ git checkout hotfix
Switched to branch &#39;hotfix&#39;
Your branch is ahead of &#39;origin/hotfix&#39; by 6 commits.
  (use &quot;git push&quot; to publish your local commits)

$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101
Merge made by the &#39;recursive&#39; strategy.
 readme.txt | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>

<p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p>

<pre><code class="language-mac">$ git checkout dev
Switched to branch &#39;dev&#39;

$ git status
On branch dev
nothing to commit, working tree clean
</code></pre>

<p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p>

<pre><code class="language-mac">$ git stash list
stash@{0}: WIP on dev: f52c633 add merge
</code></pre>

<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>

<p>一是用<code>git stash apply</code>恢复，但是恢复后，<code>stash</code>内容并不删除，你需要用<code>git stash drop</code>来删除；</p>

<p>另一种方式是用<code>git stash pop</code>，恢复的同时把<code>stash</code>内容也删了：</p>

<pre><code class="language-mac">$ git stash pop
On branch dev
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   hello.py

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   readme.txt

Dropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a)
</code></pre>

<p>再用<code>git stash list</code>查看，就看不到任何<code>stash</code>内容了：</p>

<pre><code class="language-mac">$ git stash list
</code></pre>

<p>你可以多次<code>stash</code>，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的<code>stash</code>，用命令：</p>

<pre><code class="language-mac">$ git stash apply stash@{0}
</code></pre>

<h3 id="toc_0">小结</h3>

<ol>
<li>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</li>
<li>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302562413788.html">Feature分支</a></h1>
			<p class="meta"><time datetime="2018-06-29T15:10:41+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>

<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个<code>feature</code>分支，在上面开发，完成后，合并，最后，删除该<code>feature</code>分支。</p>

<p>现在，你终于接到了一个新任务：开发代号为<code>Vulcan</code>的新功能，该功能计划用于下一代星际飞船。</p>

<p>于是准备开发：</p>

<pre><code class="language-mac">$ git checkout -b feature-vulcan
Switched to a new branch &#39;feature-vulcan&#39;
</code></pre>

<p>5分钟后，开发完毕：</p>

<pre><code class="language-mac">$ git add vulcan.py

$ git status
On branch feature-vulcan
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   vulcan.py

$ git commit -m &quot;add feature vulcan&quot;
[feature-vulcan 287773e] add feature vulcan
 1 file changed, 2 insertions(+)
 create mode 100644 vulcan.py
 ```
 
切回`dev`，准备合并：

```mac
$ git checkout dev
</code></pre>

<p>一切顺利的话，<code>feature</code>分支和<code>bug</code>分支是类似的，合并，然后删除。</p>

<p>但是！</p>

<p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p>

<p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p>

<pre><code class="language-mac">$ git branch -d feature-vulcan
error: The branch &#39;feature-vulcan&#39; is not fully merged.
If you are sure you want to delete it, run &#39;git branch -D feature-vulcan&#39;.
</code></pre>

<p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。。</p>

<p>现在我们强行删除：</p>

<pre><code class="language-mac">$ git branch -D feature-vulcan
Deleted branch feature-vulcan (was 287773e).
</code></pre>

<p>终于删除成功！</p>

<h3 id="toc_0">小结</h3>

<ol>
<li>开发一个新feature，最好新建一个分支；</li>
<li>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302564291146.html">多人协作</a></h1>
			<p class="meta"><time datetime="2018-06-29T15:13:49+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">推送分支</h3>

<p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p>

<p>要查看远程库的信息，用<code>git remote</code>：</p>

<pre><code class="language-mac">$ git remote
origin
</code></pre>

<p>或者，用git remote -v显示更详细的信息：</p>

<pre><code class="language-mac">$ git remote -v
origin  git@github.com:michaelliao/learngit.git (fetch)
origin  git@github.com:michaelliao/learngit.git (push)
</code></pre>

<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到<code>push</code>的地址。</p>

<p>推送分支<br/>
推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>

<pre><code class="language-mac">$ git push origin master
</code></pre>

<p>如果要推送其他分支，比如dev，就改成：</p>

<pre><code class="language-mac">$ git push origin dev
</code></pre>

<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>

<p><code>master</code>分支是主分支，因此要时刻与远程同步；</p>

<p><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>

<p><code>bug</code>分支只用于在本地修复<code>bug</code>，就没必要推到远程了，除非老板要看看你每周到底修复了几个<code>bug</code>；</p>

<p><code>feature</code>分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>

<p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>

<h3 id="toc_1">抓取分支</h3>

<p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p>

<p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p>

<pre><code>$ git clone git@github.com:michaelliao/learngit.git
Cloning into &#39;learngit&#39;...
remote: Counting objects: 40, done.
remote: Compressing objects: 100% (21/21), done.
remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0
Receiving objects: 100% (40/40), done.
Resolving deltas: 100% (14/14), done.
</code></pre>

<p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p>

<pre><code class="language-mac">$ git branch
* master
</code></pre>

<p>现在，你的小伙伴要在dev分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p>

<pre><code class="language-mac">$ git checkout -b dev origin/dev
</code></pre>

<p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支push到远程：</p>

<pre><code class="language-mac">$ git add env.txt

$ git commit -m &quot;add env&quot;
[dev 7a5e5dd] add env
 1 file changed, 1 insertion(+)
 create mode 100644 env.txt

$ git push origin dev
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To github.com:michaelliao/learngit.git
   f52c633..7a5e5dd  dev -&gt; dev
</code></pre>

<p>你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p>

<pre><code class="language-mac">$ cat env.txt
env

$ git add env.txt

$ git commit -m &quot;add new env&quot;
[dev 7bd91f1] add new env
 1 file changed, 1 insertion(+)
 create mode 100644 env.txt

$ git push origin dev
To github.com:michaelliao/learngit.git
 ! [rejected]        dev -&gt; dev (non-fast-forward)
error: failed to push some refs to &#39;git@github.com:michaelliao/learngit.git&#39;
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: &#39;git pull ...&#39;) before pushing again.
hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.
</code></pre>

<p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p>

<pre><code class="language-mac">$ git pull
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.

    git pull &lt;remote&gt; &lt;branch&gt;

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=origin/&lt;branch&gt; dev
</code></pre>

<p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程origin/dev分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p>

<pre><code class="language-mac">$ git branch --set-upstream-to=origin/dev dev
Branch &#39;dev&#39; set up to track remote branch &#39;dev&#39; from &#39;origin&#39;.
</code></pre>

<p>再<code>pull</code>：<br/>
mac<br/>
<code><br/>
$ git pull<br/>
Auto-merging env.txt<br/>
CONFLICT (add/add): Merge conflict in env.txt<br/>
Automatic merge failed; fix conflicts and then commit the result.<br/>
</code><br/>
这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：</p>

<pre><code class="language-mac">$ git commit -m &quot;fix env conflict&quot;
[dev 57c53ab] fix env conflict

$ git push origin dev
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.
Total 6 (delta 0), reused 0 (delta 0)
To github.com:michaelliao/learngit.git
   7a5e5dd..57c53ab  dev -&gt; dev
</code></pre>

<p>因此，多人协作的工作模式通常是这样：</p>

<p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p>

<p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p>

<p>如果合并有冲突，则解决冲突，并在本地提交；</p>

<p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p>

<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>

<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>

<h3 id="toc_2">小结</h3>

<ol>
<li>查看远程库信息，使用<code>git remote -v</code>；</li>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>
<li>本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li>
<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>
<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li>
<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>
<li><strong>推荐在每次<code>push</code>代码之前，优先<code>pull</code>当前分支,解决冲突,以避免在特殊情况下出现资源库锁住的情况</strong></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302568814111.html">Rebase</a></h1>
			<p class="meta"><time datetime="2018-06-29T15:21:21+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p>

<p>每次合并再push后，分支变成了这样：<br/>
<code>mac<br/>
$ git log --graph --pretty=oneline --abbrev-commit<br/>
* d1be385 (HEAD -&gt; master, origin/master) init hello<br/>
*   e5e69f1 Merge branch &#39;dev&#39;<br/>
|\  <br/>
| *   57c53ab (origin/dev, dev) fix env conflict<br/>
| |\  <br/>
| | * 7a5e5dd add env<br/>
| * | 7bd91f1 add new env<br/>
| |/  <br/>
* |   12a631b merged bug fix 101<br/>
|\ \  <br/>
| * | 4c805e2 fix bug 101<br/>
|/ /  <br/>
* |   e1e9c68 merge with no-ff<br/>
|\ \  <br/>
| |/  <br/>
| * f52c633 add merge<br/>
|/  <br/>
*   cf810e4 conflict fixed<br/>
</code></p>

<p>总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？</p>

<p>其实是可以做到的！</p>

<p>Git有一种称为<code>rebase</code>的操作，有人把它翻译成“变基”。</p>

<p>在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看：</p>

<pre><code class="language-mac">$ git log --graph --pretty=oneline --abbrev-commit
* 582d922 (HEAD -&gt; master) add author
* 8875536 add comment
* d1be385 (origin/master) init hello
*   e5e69f1 Merge branch &#39;dev&#39;
|\  
| *   57c53ab (origin/dev, dev) fix env conflict
| |\  
| | * 7a5e5dd add env
| * | 7bd91f1 add new env
...
</code></pre>

<p>注意到Git用<code>(HEAD -&gt; master)</code>和<code>(origin/master)</code>标识出当前分支的<code>HEAD</code>和远程<code>origin</code>的位置分别是<code>582d922 add author</code>和<code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p>

<p>现在我们尝试推送本地分支：</p>

<pre><code class="language-mac">$ git push origin master
To github.com:michaelliao/learngit.git
 ! [rejected]        master -&gt; master (fetch first)
error: failed to push some refs to &#39;git@github.com:michaelliao/learngit.git&#39;
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., &#39;git pull ...&#39;) before pushing again.
hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.
</code></pre>

<p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先<code>pull</code>一下：</p>

<pre><code class="language-mac">$ git pull
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0
Unpacking objects: 100% (3/3), done.
From github.com:michaelliao/learngit
   d1be385..f005ed4  master     -&gt; origin/master
 * [new tag]         v1.0       -&gt; v1.0
Auto-merging hello.py
Merge made by the &#39;recursive&#39; strategy.
 hello.py | 1 +
 1 file changed, 1 insertion(+)
</code></pre>

<p>再用<code>git status</code>看看状态：</p>

<pre><code class="language-mac">$ git status
On branch master
Your branch is ahead of &#39;origin/master&#39; by 3 commits.
  (use &quot;git push&quot; to publish your local commits)

nothing to commit, working tree clean
</code></pre>

<p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p>

<p>用git log看看：</p>

<pre><code class="language-mac">$ git log --graph --pretty=oneline --abbrev-commit
*   e0ea545 (HEAD -&gt; master) Merge branch &#39;master&#39; of github.com:michaelliao/learngit
|\  
| * f005ed4 (origin/master) set exit=1
* | 582d922 add author
* | 8875536 add comment
|/  
* d1be385 init hello
...
</code></pre>

<p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支<code>push</code>到远程，有没有问题？</p>

<p>这个时候，rebase就派上了用场。我们输入命令<code>git rebase</code>试试：</p>

<pre><code class="language-mac">$ git rebase
First, rewinding head to replay your work on top of it...
Applying: add comment
Using index info to reconstruct a base tree...
M    hello.py
Falling back to patching base and 3-way merge...
Auto-merging hello.py
Applying: add author
Using index info to reconstruct a base tree...
M    hello.py
Falling back to patching base and 3-way merge...
Auto-merging hello.py
</code></pre>

<p>输出了一大堆操作，到底是啥效果？再用git log看看：</p>

<pre><code class="language-mac">$ git log --graph --pretty=oneline --abbrev-commit
* 7e61ed4 (HEAD -&gt; master) add author
* 3611cfe add comment
* f005ed4 (origin/master) set exit=1
* d1be385 init hello
...
</code></pre>

<p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。<code>rebase</code>操作前后，最终的提交内容是一致的，但是，我们本地的<code>commit</code>修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p>

<p>这些命令会把你的<code>master</code>分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到<code>.git/rebase</code>目录中),然后把<code>master</code>分支更新 到最新的<code>dev</code>分支，最后把保存的这些补丁应用到<code>master</code>分支上。当<code>master</code>分支更新之后，它会指向这些新创建的提交(commit),而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection), 这些被丢弃的提交就会删除。</p>

<p>这就是<code>rebase</code>操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p>

<p>最后，通过push操作把本地分支推送到远程：</p>

<pre><code class="language-mac">Mac:~/learngit michael$ git push origin master
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.
Total 6 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 1 local object.
To github.com:michaelliao/learngit.git
   f005ed4..7e61ed4  master -&gt; master
</code></pre>

<p>再用git log看看效果：</p>

<pre><code class="language-mac">$ git log --graph --pretty=oneline --abbrev-commit
* 7e61ed4 (HEAD -&gt; master, origin/master) add author
* 3611cfe add comment
* f005ed4 set exit=1
* d1be385 init hello
...
</code></pre>

<p>远程分支的提交历史也是一条直线。</p>

<p>在<code>rebase</code>的过程中，也许会出现冲突(conflict). 在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用<code>git-add</code>命令去更新这些内容的索引(index), 然后，你无需执行 <code>git-commit</code>,只要执行:<br/>
<code><br/>
</code><code>mac<br/>
$ git rebase --continue<br/>
</code><code><br/>
这样git会继续应用(</code>apply`)余下的补丁。</p>

<p>在任何时候，你可以用<code>--abort</code>参数来终止<code>rebase</code>的行动，并且<code>mywork</code> 分支会回到<code>rebase</code>开始前的状态。</p>

<pre><code class="language-mac">$ git rebase --abort
</code></pre>

<h3 id="toc_0">小结</h3>

<ol>
<li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li>
<li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li>
<li><strong>一般我们<code>release</code>分支到<code>master</code>分支的时候可以使用<code>rebase</code>，直线是正常的版本迭代，分支是hotfix修复后数据的迭代，不用追溯到具体的提交点</strong></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302581196609.html">标签管理</a></h1>
			<p class="meta"><time datetime="2018-06-29T15:41:59+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">标签介绍</h3>

<p>发布一个版本时，我们通常先在版本库中打一个标签（<code>tag</code>），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>

<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>

<p>Git有<code>commit</code>，为什么还要引入<code>tag</code>？</p>

<p>“请把上周一的那个版本打包发布，<code>commit</code>号是6a5819e...”<br/>
“一串乱七八糟的数字不好找！”</p>

<p>如果换一个办法：<br/>
“请把上周一的那个版本打包发布，版本号是v1.2”<br/>
“好的，按照tag v1.2查找commit就行！”</p>

<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>

<h3 id="toc_1">创建标签</h3>

<p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p>

<pre><code class="language-mac">$ git branch
* dev
  master
$ git checkout master
Switched to branch &#39;master&#39;
</code></pre>

<p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p>

<pre><code class="language-mac">$ git tag v1.0
</code></pre>

<p>可以用命令<code>git tag</code>查看所有标签：</p>

<pre><code class="language-mac">$ git tag
v1.0
</code></pre>

<p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>

<p>方法是找到历史提交的commit id，然后打上就可以了：</p>

<pre><code class="language-mac">$ git log --pretty=oneline --abbrev-commit
12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101
4c805e2 fix bug 101
e1e9c68 merge with no-ff
f52c633 add merge
cf810e4 conflict fixed
5dc6824 &amp; simple
14096d0 AND simple
b17d20e branch test
d46f35e remove test.txt
b84166e add test.txt
519219b git tracks changes
e43a48b understand how stage works
1094adb append GPL
e475afc add distributed
eaadf4e wrote a readme file
</code></pre>

<p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是f52c633，敲入命令：</p>

<pre><code class="language-mac">$ git tag v0.9 f52c633
</code></pre>

<p>再用命令<code>git tag</code>查看标签：</p>

<pre><code class="language-mac">$ git tag
v0.9
v1.0
</code></pre>

<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p>

<pre><code class="language-mac">$ git show v0.9
commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:56:54 2018 +0800

    add merge

diff --git a/readme.txt b/readme.txt
...
</code></pre>

<p>可以看到，v0.9确实打在<code>add merge</code>这次提交上。</p>

<p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p>

<pre><code class="language-mac">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb
</code></pre>

<p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p>

<pre><code class="language-mac">$ git show v0.1
tag v0.1
Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 22:48:43 2018 +0800

version 0.1 released

commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:06:15 2018 +0800

    append GPL

diff --git a/readme.txt b/readme.txt
...
</code></pre>

<p>注: 标签和提交的关联<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<h3 id="toc_2">操作标签</h3>

<p>如果标签打错了，也可以删除：</p>

<pre><code class="language-mac">$ git tag -d v0.1
Deleted tag &#39;v0.1&#39; (was f15b0dd)
</code></pre>

<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>

<p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p>

<pre><code class="language-mac">$ git push origin v1.0
Total 0 (delta 0), reused 0 (delta 0)
To github.com:michaelliao/learngit.git
 * [new tag]         v1.0 -&gt; v1.0
</code></pre>

<p>或者，一次性推送全部尚未推送到远程的本地标签：</p>

<pre><code class="language-mac">$ git push origin --tags
Total 0 (delta 0), reused 0 (delta 0)
To github.com:michaelliao/learngit.git
 * [new tag]         v0.9 -&gt; v0.9
</code></pre>

<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p>

<pre><code class="language-mac">$ git tag -d v0.9
Deleted tag &#39;v0.9&#39; (was f52c633)
</code></pre>

<p>然后，从远程删除。删除命令也是push，但是格式如下：</p>

<pre><code>$ git push origin :refs/tags/v0.9
To github.com:michaelliao/learngit.git
 - [deleted]         v0.9
</code></pre>

<p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看</p>

<h3 id="toc_3">小结</h3>

<ol>
<li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li>
<li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li>
<li>命令<code>git tag</code>可以查看所有标签。</li>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
<li><strong>强烈建议每一个正式环境的版本必须打包，并需要遵循语义化版本(2.0.0)[<a href="https://semver.org/lang/zh-CN/">https://semver.org/lang/zh-CN/</a>]</strong></li>
</ol>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302592642979.html">忽略特殊文件</a></h1>
			<p class="meta"><time datetime="2018-06-29T16:01:04+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files ...，有强迫症的童鞋心里肯定不爽。</p>

<p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>

<p>不需要从头写<code>.gitignore</code>文件，<code>GitHub</code>已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<code>https://github.com/github/gitignore</code></p>

<p>忽略文件的原则是：</p>

<p>忽略操作系统自动生成的文件，比如缩略图等；<br/>
忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；<br/>
忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。<br/>
举个例子：</p>

<p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有<code>Desktop.ini</code>文件，因此你需要忽略Windows自动生成的垃圾文件：</p>

<pre><code class="language-mac"># Windows:
Thumbs.db
ehthumbs.db
Desktop.ini
</code></pre>

<p>然后，继续忽略<code>Python</code>编译产生的<code>.pyc、.pyo、dist</code>等文件或目录：</p>

<pre><code class="language-mac"># Python:
*.py[cod]
*.so
*.egg
*.egg-info
dist
build
</code></pre>

<p>加上你自己定义的文件，最终得到一个完整的<code>.gitignore</code>文件，内容如下：</p>

<pre><code class="language-mac"># Windows:
Thumbs.db
ehthumbs.db
Desktop.ini

# Python:
*.py[cod]
*.so
*.egg
*.egg-info
dist
build

# My configurations:
db.ini
deploy_key_rsa
</code></pre>

<p>最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说working directory clean。</p>

<p>使用Windows的童鞋注意了，如果你在资源管理器里新建一个<code>.gitignore</code>文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为<code>.gitignore</code>了。</p>

<p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了：</p>

<pre><code class="language-mac">$ git add App.class
The following paths are ignored by one of your .gitignore files:
App.class
Use -f if you really want to add them.
</code></pre>

<p>如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p>

<pre><code class="language-mac">$ git add -f App.class
</code></pre>

<p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p>

<pre><code class="language-mac">$ git check-ignore -v App.class
.gitignore:3:*.class    App.class
</code></pre>

<p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>

<h3 id="toc_0">小结</h3>

<ol>
<li>忽略某些文件时，需要编写<code>.gitignore</code>；</li>
<li><code>.gtignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15302594037991.html">配置别名</a></h1>
			<p class="meta"><time datetime="2018-06-29T16:03:23+08:00" 
			pubdate data-updated="true">2018/6/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>有没有经常敲错命令？比如<code>git status</code>？<code>status</code>这个单词真心不好记。</p>

<p>如果敲<code>git st</code>就表示<code>git status</code>那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p>

<p>我们只需要敲一行命令，告诉Git，以后st就表示status：</p>

<pre><code class="language-mac">$ git config --global alias.st status
</code></pre>

<p>好了，现在敲<code>git st</code>看看效果。</p>

<p>当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，ci表示<code>commit</code>，<code>br</code>表示<code>branch</code>：</p>

<pre><code class="language-mac">$ git config --global alias.co checkout
$ git config --global alias.ci commit
$ git config --global alias.br branch
</code></pre>

<p>以后提交就可以简写成：</p>

<pre><code class="language-mac">$ git ci -m &quot;bala bala bala...&quot;
</code></pre>

<p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p>

<p>在撤销修改一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：</p>

<pre><code class="language-mac">$ git config --global alias.unstage &#39;reset HEAD&#39;
</code></pre>

<p>当你敲入命令：</p>

<pre><code class="language-mac">$ git unstage test.py
</code></pre>

<p>实际上Git执行的是：</p>

<pre><code class="language-mac">$ git reset HEAD test.py
</code></pre>

<p>配置一个git last，让其显示最后一次提交信息：</p>

<pre><code class="language-mac">$ git config --global alias.last &#39;log -1&#39;
</code></pre>

<p>这样，用git last就能显示最近一次的提交：</p>

<pre><code class="language-mac">$ git last
commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2
Merge: bd6ae48 291bea8
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Thu Aug 22 22:49:22 2013 +0800

    merge &amp; fix hello.py
</code></pre>

<p>甚至还有人丧心病狂地把<code>lg</code>配置成了：</p>

<pre><code class="language-mac">git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;
</code></pre>

<p>来看看<code>git lg</code>的效果：<br/>
<img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/00138492662982594cbd1a942114472aeeb5f0a502faed1000/0" alt=""/></p>

<h3 id="toc_0">配置文件</h3>

<p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>

<p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p>

<pre><code class="language-mac">$ cat .git/config 
[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
    ignorecase = true
    precomposeunicode = true
[remote &quot;origin&quot;]
    url = git@github.com:michaelliao/learngit.git
    fetch = +refs/heads/*:refs/remotes/origin/*
[branch &quot;master&quot;]
    remote = origin
    merge = refs/heads/master
[alias]
    last = log -1
</code></pre>

<p>别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。</p>

<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中：</p>

<pre><code class="language-mac">$ cat .gitconfig
[alias]
    co = checkout
    ci = commit
    br = branch
    st = status
[user]
    name = Your Name
    email = your@email.com
</code></pre>

<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>

<p>小结<br/>
给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_1.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="Git%E7%89%88%E6%9C%AC%E5%B7%A5%E5%85%B7.html"><strong>Git版本工具&nbsp;(23)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="Git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html">Git基础知识&nbsp;(20)</a>&nbsp;&nbsp;
	        
	        	<a href="Git-Flow%E4%BD%BF%E7%94%A8.html">Git-Flow使用&nbsp;(3)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15302416575923.html">Git安装</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15302427999465.html">版本库创建</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15302446124635.html">版本更新</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15302503418505.html">版本回退</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15302512669411.html">工作区和暂存区</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    

<script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>